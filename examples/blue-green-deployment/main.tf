provider "aws" {
  region = local.region
}

data "aws_availability_zones" "available" {}
data "aws_caller_identity" "current" {}
data "aws_iam_role" "ecs_core_infra_exec_role" {
  name = var.ecs_task_execution_role_name
}

locals {
  name   = basename(path.cwd)
  region = "us-west-2"

  vpc_cidr = "10.0.0.0/16"
  azs      = slice(data.aws_availability_zones.available.names, 0, 3)

  app_server_port = 3001
  app_client_port = 80

  tags = {
    Blueprint  = local.name
    GithubRepo = "github.com/${var.repository_owner}/terraform-aws-ecs-blueprints"
  }
}

################################################################################
# ECS Blueprint
################################################################################

module "ecs" {
  source  = "terraform-aws-modules/ecs/aws"
  version = "~> 4.1"

  cluster_name = local.name

  tags = local.tags
}

module "client_alb_security_group" {
  source  = "terraform-aws-modules/security-group/aws"
  version = "~> 4.0"

  name        = "${local.name}-client"
  description = "Security group for client application"
  vpc_id      = module.vpc.vpc_id

  ingress_rules       = ["http-80-tcp"]
  ingress_cidr_blocks = ["0.0.0.0/0"]

  egress_rules       = ["all-all"]
  egress_cidr_blocks = module.vpc.private_subnets_cidr_blocks

  tags = local.tags
}

module "client_alb" {
  source  = "terraform-aws-modules/alb/aws"
  version = "~> 7.0"

  name = "${local.name}-client"

  load_balancer_type = "application"

  vpc_id          = module.vpc.vpc_id
  subnets         = module.vpc.public_subnets
  security_groups = [module.client_alb_security_group.security_group_id]

  target_groups = [
    {
      name             = "client-blue"
      backend_protocol = "HTTP"
      backend_port     = 80
      target_type      = "ip"
      health_check = {
        path    = "/"
        port    = local.app_client_port
        matcher = "200-299"
      }
    },
    {
      name             = "client-green"
      backend_protocol = "HTTP"
      backend_port     = 80
      target_type      = "ip"
      health_check = {
        path    = "/"
        port    = local.app_client_port
        matcher = "200-299"
      }
    }
  ]

  tags = local.tags
}

resource "aws_alb_listener" "client" {
  load_balancer_arn = module.client_alb.lb_id
  port              = 80
  protocol          = "HTTP"

  default_action {
    target_group_arn = element(module.client_alb.target_group_arns, 0)
    type             = "forward"
  }

  lifecycle {
    # to avoid changes generated by CodeDeploy changes
    ignore_changes = [default_action]
  }

  tags = local.tags
}

module "server_alb_security_group" {
  source  = "terraform-aws-modules/security-group/aws"
  version = "~> 4.0"

  name        = "${local.name}-client"
  description = "Security group for client application"
  vpc_id      = module.vpc.vpc_id

  ingress_with_source_security_group_id = [
    {
      rule                     = "http-80-tcp"
      source_security_group_id = module.client_alb_security_group.security_group_id
    },
  ]

  egress_rules       = ["all-all"]
  egress_cidr_blocks = module.vpc.private_subnets_cidr_blocks

  tags = local.tags
}

module "server_alb" {
  source  = "terraform-aws-modules/alb/aws"
  version = "~> 7.0"

  name = "${local.name}-server"

  load_balancer_type = "application"
  internal           = true

  vpc_id          = module.vpc.vpc_id
  subnets         = module.vpc.private_subnets
  security_groups = [module.server_alb_security_group.security_group_id]

  target_groups = [
    {
      name             = "server-blue"
      backend_protocol = "HTTP"
      backend_port     = 80
      target_type      = "ip"
      health_check = {
        path    = "/status"
        port    = local.app_server_port
        matcher = "200-299"
      }
    },
    {
      name             = "server-green"
      backend_protocol = "HTTP"
      backend_port     = 80
      target_type      = "ip"
      health_check = {
        path    = "/status"
        port    = local.app_server_port
        matcher = "200-299"
      }
    },
  ]

  tags = local.tags
}

resource "aws_alb_listener" "server" {
  load_balancer_arn = module.server_alb.lb_id
  port              = 80
  protocol          = "HTTP"

  default_action {
    target_group_arn = element(module.server_alb.target_group_arns, 0)
    type             = "forward"
  }

  lifecycle {
    # to avoid changes generated by CodeDeploy changes
    ignore_changes = [default_action]
  }

  tags = local.tags
}

module "server_ecr" {
  source  = "terraform-aws-modules/ecr/aws"
  version = "~> 1.4"

  repository_name = "${local.name}-server"

  repository_force_delete           = true
  create_lifecycle_policy           = false
  repository_read_access_arns       = [data.aws_iam_role.ecs_core_infra_exec_role.arn]
  repository_read_write_access_arns = [module.devops_role.devops_role_arn]

  tags = local.tags
}

module "client_ecr" {
  source  = "terraform-aws-modules/ecr/aws"
  version = "~> 1.4"

  repository_name = "${local.name}-client"

  repository_force_delete           = true
  create_lifecycle_policy           = false
  repository_read_access_arns       = [data.aws_iam_role.ecs_core_infra_exec_role.arn]
  repository_read_write_access_arns = [module.devops_role.devops_role_arn]

  tags = local.tags
}

data "aws_iam_policy_document" "task_role" {
  statement {
    sid = "S3Read"
    actions = [
      "s3:GetObject",
      "s3:ListBucket",
    ]
    resources = [
      module.assets_s3_bucket.s3_bucket_arn,
      "${module.assets_s3_bucket.s3_bucket_arn}/*",
    ]
  }

  statement {
    sid       = "IAMPassRole"
    actions   = ["iam:PassRole"]
    resources = ["*"]
  }

  statement {
    sid = "DynamoDBReadWrite"
    actions = [
      "dynamodb:BatchGetItem",
      "dynamodb:Describe*",
      "dynamodb:List*",
      "dynamodb:GetItem",
      "dynamodb:Query",
      "dynamodb:Scan",
    ]
    resources = [module.assets_dynamodb_table.dynamodb_table_arn]
  }
}

module "client_task_security_group" {
  source  = "terraform-aws-modules/security-group/aws"
  version = "~> 4.0"

  name        = "${local.name}-client-task"
  description = "Security group for client task"
  vpc_id      = module.vpc.vpc_id

  ingress_with_source_security_group_id = [
    {
      rule                     = "http-80-tcp"
      source_security_group_id = module.client_alb_security_group.security_group_id
    },
  ]

  egress_rules = ["all-all"]

  tags = local.tags
}

module "server_task_security_group" {
  source  = "terraform-aws-modules/security-group/aws"
  version = "~> 4.0"

  name        = "${local.name}-server-task"
  description = "Security group for server task"
  vpc_id      = module.vpc.vpc_id

  ingress_with_source_security_group_id = [
    {
      from_port                = local.app_server_port
      to_port                  = local.app_server_port
      protocol                 = "tcp"
      source_security_group_id = module.server_alb_security_group.security_group_id
    },
  ]

  egress_rules = ["all-all"]

  tags = local.tags
}

module "ecs_service_server" {
  source = "../../modules/ecs-service"

  name           = "${local.name}-server"
  desired_count  = 1
  ecs_cluster_id = module.ecs.cluster_id

  security_groups = [module.server_task_security_group.security_group_id]
  subnets         = module.vpc.private_subnets

  load_balancers = [{
    target_group_arn = element(module.server_alb.target_group_arns, 0)
  }]
  deployment_controller = "CODE_DEPLOY"

  # Task Definition
  container_name     = "${local.name}-server"
  container_port     = local.app_server_port
  cpu                = 256
  memory             = 512
  image              = module.server_ecr.repository_url
  task_role_policy   = data.aws_iam_policy_document.task_role.json
  execution_role_arn = data.aws_iam_role.ecs_core_infra_exec_role.arn

  # Autoscalnig
  enable_autoscaling           = true
  autoscaling_min_capacity     = 1
  autoscaling_max_capacity     = 8
  autoscaling_cpu_threshold    = 75
  autoscaling_memory_threshold = 75

  tags = local.tags
}

module "ecs_service_client" {
  source = "../../modules/ecs-service"

  name           = "${local.name}-client"
  desired_count  = 1
  ecs_cluster_id = module.ecs.cluster_id

  security_groups = [module.client_task_security_group.security_group_id]
  subnets         = module.vpc.private_subnets

  load_balancers = [{
    container_name   = "${local.name}-client"
    container_port   = local.app_client_port
    target_group_arn = element(module.client_alb.target_group_arns, 0)
  }]
  deployment_controller = "CODE_DEPLOY"

  # Task Definition
  container_name     = "${local.name}-client"
  container_port     = local.app_client_port
  cpu                = 256
  memory             = 512
  image              = module.client_ecr.repository_url
  task_role_policy   = data.aws_iam_policy_document.task_role.json
  execution_role_arn = data.aws_iam_role.ecs_core_infra_exec_role.arn

  # Autoscalnig
  enable_autoscaling           = true
  autoscaling_min_capacity     = 1
  autoscaling_max_capacity     = 8
  autoscaling_cpu_threshold    = 75
  autoscaling_memory_threshold = 75

  tags = local.tags
}

################################################################################
# CodePipeline
################################################################################

module "codepipeline_s3_bucket" {
  source  = "terraform-aws-modules/s3-bucket/aws"
  version = "~> 3.0"

  bucket = "codepipeline-${local.region}-${random_id.this.hex}"
  acl    = "private"

  # For example only - please re-evaluate for your environment
  force_destroy = true

  attach_deny_insecure_transport_policy = true
  attach_require_latest_tls_policy      = true

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  tags = local.tags
}

resource "aws_sns_topic" "codestar_notification" {
  name = local.name

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid      = "WriteAccess"
        Effect   = "Allow"
        Action   = "sns:Publish"
        Resource = "arn:aws:sns:${local.region}:${data.aws_caller_identity.current.account_id}:${local.name}"
        Principal = {
          Service = "codestar-notifications.amazonaws.com"
        }
      },
    ]
  })

  tags = local.tags
}

module "devops_role" {
  source = "../../modules/iam"

  create_devops_role = true

  name                  = "${local.name}-devops"
  ecr_repositories      = [module.server_ecr.repository_arn, module.client_ecr.repository_arn]
  code_build_projects   = [module.codebuild_client.project_arn, module.codebuild_server.project_arn]
  code_deploy_resources = [module.codedeploy_server.application_arn, module.codedeploy_server.deployment_group_arn, module.codedeploy_client.application_arn, module.codedeploy_client.deployment_group_arn]

  tags = local.tags
}

module "codedeploy_role" {
  source = "../../modules/iam"

  create_codedeploy_role = true

  name = "${local.name}-codedeploy"

  tags = local.tags
}

module "codebuild_server" {
  source = "../../modules/codebuild"

  name           = "codebuild-${module.ecs_service_server.name}"
  service_role   = module.devops_role.devops_role_arn
  buildspec_path = var.buildspec_path

  environment = {
    privileged_mode = true
    environment_variables = [
      {
        name  = "REPO_URL"
        value = module.server_ecr.repository_url
        }, {
        name  = "DYNAMODB_TABLE"
        value = module.assets_dynamodb_table.dynamodb_table_id
        }, {
        name  = "TASK_DEFINITION_FAMILY"
        value = module.ecs_service_server.task_definition_family
        }, {
        name  = "CONTAINER_NAME"
        value = module.ecs_service_server.container_name
        }, {
        name  = "SERVICE_PORT"
        value = local.app_server_port
        }, {
        name  = "FOLDER_PATH"
        value = var.folder_path_server
        }, {
        name  = "ECS_TASK_ROLE_ARN"
        value = module.ecs_service_server.task_role_arn
        }, {
        name  = "ECS_EXEC_ROLE_ARN"
        value = data.aws_iam_role.ecs_core_infra_exec_role.arn
      },
    ]
  }

  tags = local.tags
}

module "codebuild_client" {
  source = "../../modules/codebuild"

  name           = "codebuild-${module.ecs_service_client.name}"
  service_role   = module.devops_role.devops_role_arn
  buildspec_path = var.buildspec_path

  environment = {
    privileged_mode = true
    environment_variables = [
      {
        name  = "REPO_URL"
        value = module.client_ecr.repository_url
        }, {
        name  = "TASK_DEFINITION_FAMILY"
        value = module.ecs_service_client.task_definition_family
        }, {
        name  = "CONTAINER_NAME"
        value = module.ecs_service_client.container_name
        }, {
        name  = "SERVICE_PORT"
        value = local.app_client_port
        }, {
        name  = "FOLDER_PATH"
        value = var.folder_path_client
        }, {
        name  = "ECS_TASK_ROLE_ARN"
        value = module.ecs_service_client.task_role_arn
        }, {
        name  = "ECS_EXEC_ROLE_ARN"
        value = data.aws_iam_role.ecs_core_infra_exec_role.arn
        }, {
        name  = "SERVER_ALB_URL"
        value = module.server_alb.lb_dns_name
      }
    ]
  }

  tags = local.tags
}

module "codedeploy_server" {
  source = "../../modules/codedeploy"

  name            = "Deploy-${local.name}-server"
  ecs_cluster     = module.ecs.cluster_name
  ecs_service     = module.ecs_service_server.name
  alb_listener    = aws_alb_listener.server.arn
  tg_blue         = element(module.server_alb.target_group_names, 0)
  tg_green        = element(module.server_alb.target_group_names, 1)
  sns_topic_arn   = aws_sns_topic.codestar_notification.arn
  codedeploy_role = module.codedeploy_role.codedeploy_role_arn

  tags = local.tags
}

module "codedeploy_client" {
  source = "../../modules/codedeploy"

  name            = "Deploy-${local.name}-client"
  ecs_cluster     = module.ecs.cluster_name
  ecs_service     = module.ecs_service_client.name
  alb_listener    = aws_alb_listener.client.arn
  tg_blue         = element(module.client_alb.target_group_names, 0)
  tg_green        = element(module.client_alb.target_group_names, 1)
  sns_topic_arn   = aws_sns_topic.codestar_notification.arn
  codedeploy_role = module.codedeploy_role.codedeploy_role_arn

  tags = local.tags
}

data "aws_secretsmanager_secret" "github_token" {
  name = "ecs-github-token"
}

data "aws_secretsmanager_secret_version" "github_token" {
  secret_id = data.aws_secretsmanager_secret.github_token.id
}

module "codepipeline_server" {
  source = "../../modules/codepipeline"

  name                  = "pipeline-${module.ecs_service_server.name}"
  pipe_role             = module.devops_role.devops_role_arn
  s3_bucket             = module.codepipeline_s3_bucket.s3_bucket_id
  github_token          = data.aws_secretsmanager_secret_version.github_token.secret_string
  repo_owner            = var.repository_owner
  repo_name             = var.repository_name
  branch                = var.repository_branch
  codebuild_project_app = module.codebuild_server.project_id
  sns_topic             = aws_sns_topic.codestar_notification.arn
  deploy_provider       = "CodeDeployToECS"

  app_deploy_configuration = {
    ApplicationName                = module.codedeploy_server.application_name
    DeploymentGroupName            = module.codedeploy_server.deployment_group_name
    TaskDefinitionTemplateArtifact = "BuildArtifact_app"
    TaskDefinitionTemplatePath     = "taskdef.json"
    AppSpecTemplateArtifact        = "BuildArtifact_app"
    AppSpecTemplatePath            = "appspec.yaml"
  }

  tags = local.tags
}

module "codepipeline_client" {
  source = "../../modules/codepipeline"

  name                  = "pipeline-${module.ecs_service_client.name}"
  pipe_role             = module.devops_role.devops_role_arn
  s3_bucket             = module.codepipeline_s3_bucket.s3_bucket_id
  github_token          = data.aws_secretsmanager_secret_version.github_token.secret_string
  repo_owner            = var.repository_owner
  repo_name             = var.repository_name
  branch                = var.repository_branch
  codebuild_project_app = module.codebuild_client.project_id
  sns_topic             = aws_sns_topic.codestar_notification.arn
  deploy_provider       = "CodeDeployToECS"

  app_deploy_configuration = {
    ApplicationName                = module.codedeploy_client.application_name
    DeploymentGroupName            = module.codedeploy_client.deployment_group_name
    TaskDefinitionTemplateArtifact = "BuildArtifact_app"
    TaskDefinitionTemplatePath     = "taskdef.json"
    AppSpecTemplateArtifact        = "BuildArtifact_app"
    AppSpecTemplatePath            = "appspec.yaml"
  }

  tags = local.tags
}

################################################################################
# Assets
################################################################################

module "assets_s3_bucket" {
  source  = "terraform-aws-modules/s3-bucket/aws"
  version = "~> 3.0"

  bucket = "${local.name}-assets-${local.region}-${random_id.this.hex}"
  acl    = "private"

  # For example only - please re-evaluate for your environment
  force_destroy = true

  attach_deny_insecure_transport_policy = true
  attach_require_latest_tls_policy      = true

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true

  server_side_encryption_configuration = {
    rule = {
      apply_server_side_encryption_by_default = {
        sse_algorithm = "AES256"
      }
    }
  }

  tags = local.tags
}

module "assets_dynamodb_table" {
  source  = "terraform-aws-modules/dynamodb-table/aws"
  version = "~> 2.0"

  name     = "${local.name}-assets"
  hash_key = "id"

  attributes = [
    {
      name = "id"
      type = "N"
    }
  ]

  tags = local.tags
}

################################################################################
# Supporting Resources
################################################################################

module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 3.0"

  name = local.name
  cidr = local.vpc_cidr

  azs             = local.azs
  public_subnets  = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k)]
  private_subnets = [for k, v in local.azs : cidrsubnet(local.vpc_cidr, 8, k + 10)]

  enable_nat_gateway   = true
  single_nat_gateway   = true
  enable_dns_hostnames = true

  # Manage so we can name
  manage_default_network_acl    = true
  default_network_acl_tags      = { Name = "${local.name}-default" }
  manage_default_route_table    = true
  default_route_table_tags      = { Name = "${local.name}-default" }
  manage_default_security_group = true
  default_security_group_tags   = { Name = "${local.name}-default" }

  tags = local.tags
}

resource "random_id" "this" {
  byte_length = "2"
}
